<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>spring webflux | 剑君 の Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="WebFluxWebFlux 简介">
<meta property="og:type" content="article">
<meta property="og:title" content="spring webflux">
<meta property="og:url" content="https://hejianjun.github.io/2018/06/29/spring-webflux/index.html">
<meta property="og:site_name" content="剑君 の Blog">
<meta property="og:description" content="WebFluxWebFlux 简介">
<meta property="og:locale">
<meta property="og:image" content="https://hejianjun.github.io/images/spring-webflux.png">
<meta property="og:image" content="https://hejianjun.github.io/images/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81.png">
<meta property="article:published_time" content="2018-06-28T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-08T06:42:16.183Z">
<meta property="article:author" content="Hejianjun">
<meta property="article:tag" content="webflux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hejianjun.github.io/images/spring-webflux.png">
  
    <link rel="alternate" href="/atom.xml" title="剑君 の Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">剑君 の Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hejianjun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-spring-webflux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/29/spring-webflux/" class="article-date">
  <time datetime="2018-06-28T16:00:00.000Z" itemprop="datePublished">2018-06-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/technology/">technology</a>►<a class="article-category-link" href="/categories/technology/webflux/">webflux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      spring webflux
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h1><h2 id="WebFlux-简介"><a href="#WebFlux-简介" class="headerlink" title="WebFlux 简介"></a>WebFlux 简介</h2><p><img src="/images/spring-webflux.png" alt="WebFlux"></p>
<span id="more"></span>
<p>WebFlux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 <code>Flux</code>。该模块中包含了对反应式 HTTP、服务器推送事件和 WebSocket 的客户端和服务器端的支持。对于开发人员来说，比较重要的是服务器端的开发，这也是本文的重点。在服务器端，WebFlux 支持两种不同的编程模型：第一种是 Spring MVC 中使用的基于 Java 注解的方式；第二种是基于 Java 8 的 lambda 表达式的函数式编程模型。这两种编程模型只是在代码编写方式上存在不同。它们运行在同样的反应式底层架构之上，因此在运行时是相同的。WebFlux 需要底层提供运行时的支持，WebFlux 可以运行在支持 Servlet 3.1 非阻塞 IO API 的 Servlet 容器上，或是其他异步运行时环境，如 Netty 和 Undertow。</p>
<p>最方便的创建 WebFlux 应用的方式是使用 Spring Boot 提供的应用模板。直接访问 Spring Initializ 网站（<a target="_blank" rel="noopener" href="http://start.spring.io/%EF%BC%89%EF%BC%8C%E9%80%89%E6%8B%A9%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA">http://start.spring.io/），选择创建一个</a> Maven 或 Gradle 项目。Spring Boot 的版本选择 2.0.0 M2。在添加的依赖中，选择 Reactive Web。最后输入应用所在的分组和名称，点击进行下载即可。需要注意的是，只有在选择了 Spring Boot 2.0.0 M2 之后，依赖中才可以选择 Reactive Web。下载完成之后可以导入到 IDE 中进行编辑。本文的示例代码使用 Intellij IDEA 2017.2 进行编写。</p>
<p>本文从三个方面对 WebFlux 进行介绍。首先是使用经典的基于 Java 注解的编程模型来进行开发，其次是使用 WebFlux 新增的函数式编程模型来进行开发，最后介绍 WebFlux 应用的测试。通过这样循序渐进的方式让读者了解 WebFlux 应用开发的细节。</p>
<h2 id="Java-注解编程模型"><a href="#Java-注解编程模型" class="headerlink" title="Java 注解编程模型"></a>Java 注解编程模型</h2><p>基于 Java 注解的编程模型，对于使用过 Spring MVC 的开发人员来说是再熟悉不过的。在 WebFlux 应用中使用同样的模式，容易理解和上手。我们先从最经典的 Hello World 的示例开始说明。代码清单 1 中的 <code>BasicController</code> 是 REST API 的控制器，通过<code>@RestController</code> 注解来声明。在 <code>BasicController</code> 中声明了一个 URI 为<code>/hello_world</code> 的映射。其对应的方法 <code>sayHelloWorld(</code>的返回值是 <code>Mono&lt;String&gt;</code>类型，其中包含的字符串”Hello World”会作为 HTTP 的响应内容。</p>
<h5 id="清单-1-Hello-World-示例"><a href="#清单-1-Hello-World-示例" class="headerlink" title="清单 1. Hello World 示例"></a>清单 1. Hello World 示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello_world&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">sayHelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码清单 1 中可以看到，使用 WebFlux 与 Spring MVC 的不同在于，WebFlux 所使用的类型是与反应式编程相关的 <code>Flux</code> 和 <code>Mono</code> 等，而不是简单的对象。对于简单的 Hello World 示例来说，这两者之间并没有什么太大的差别。对于复杂的应用来说，反应式编程和负压的优势会体现出来，可以带来整体的性能的提升。</p>
<h3 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h3><p>简单的 Hello World 示例并不足以说明 WebFlux 的用法。在下面的小节中，本文将介绍其他具体的实例。先从 REST API 开始说起。REST API 在 Web 服务器端应用中占据了很大的一部分。我们通过一个具体的实例来说明如何使用 WebFlux 来开发 REST API。</p>
<p>该 REST API 用来对用户数据进行基本的 CRUD 操作。作为领域对象的 User 类中包含了 id、name 和 email 等三个基本的属性。为了对 User 类进行操作，我们需要提供服务类 UserService，如代码清单 2 所示。类 UserService 使用一个 Map 来保存所有用户的信息，并不是一个持久化的实现。这对于示例应用来说已经足够了。类 UserService 中的方法都以 Flux 或 Mono 对象作为返回值，这也是 WebFlux 应用的特征。在方法 getById()中，如果找不到 ID 对应的 User 对象，会返回一个包含了 <code>ResourceNotFoundException</code> 异常通知的 Mono 对象。方法 <code>getById()</code>和 <code>createOrUpdate()</code>都可以接受<code>String</code> 或 <code>Flux</code> 类型的参数。<code>Flux</code> 类型的参数表示的是有多个对象需要处理。这里使用 <code>doOnNext()</code>来对其中的每个对象进行处理。</p>
<h5 id="清单-2-UserService"><a href="#清单-2-UserService" class="headerlink" title="清单 2. UserService"></a>清单 2. UserService</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, User&gt; data = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    Flux&lt;User&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Flux.fromIterable(<span class="built_in">this</span>.data.values());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Flux&lt;User&gt; <span class="title function_">getById</span><span class="params">(<span class="keyword">final</span> Flux&lt;String&gt; ids)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ids.flatMap(id -&gt; Mono.justOrEmpty(<span class="built_in">this</span>.data.get(id)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Mono&lt;User&gt; <span class="title function_">getById</span><span class="params">(<span class="keyword">final</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(<span class="built_in">this</span>.data.get(id))</span><br><span class="line">                .switchIfEmpty(Mono.error(<span class="keyword">new</span> <span class="title class_">ResourceNotFoundException</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Mono&lt;User&gt; <span class="title function_">createOrUpdate</span><span class="params">(<span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data.put(user.getId(), user);</span><br><span class="line">        <span class="keyword">return</span> Mono.just(user);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Mono&lt;User&gt; <span class="title function_">delete</span><span class="params">(<span class="keyword">final</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(<span class="built_in">this</span>.data.remove(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单 3 中的类 <code>UserController</code> 是具体的 Spring MVC 控制器类。它使用类 <code>UserService</code> 来完成具体的功能。类 UserController 中使用了注解<code>@ExceptionHandler</code> 来添加了 <code>ResourceNotFoundException</code> 异常的处理方法，并返回 404 错误。类 <code>UserController</code> 中的方法都很简单，只是简单地代理给 <code>UserService</code> 中的对应方法。</p>
<h5 id="清单-3-UserController"><a href="#清单-3-UserController" class="headerlink" title="清单 3. UserController"></a>清单 3. UserController</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(<span class="keyword">final</span> UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = &quot;Resource not found&quot;)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notFound</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userService.list();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt;getById(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">final</span> String id) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userService.createOrUpdate(user);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt;  <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">final</span> String id, <span class="meta">@RequestBody</span> <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(user);</span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userService.createOrUpdate(user);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt;  <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">final</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器推送事件"><a href="#服务器推送事件" class="headerlink" title="服务器推送事件"></a>服务器推送事件</h3><p>服务器推送事件（Server-Sent Events，SSE）允许服务器端不断地推送数据到客户端。相对于 WebSocket 而言，服务器推送事件只支持服务器端到客户端的单向数据传递。虽然功能较弱，但优势在于 SSE 在已有的 HTTP 协议上使用简单易懂的文本格式来表示传输的数据。作为 W3C 的推荐规范，SSE 在浏览器端的支持也比较广泛，除了 IE 之外的其他浏览器都提供了支持。在 IE 上也可以使用 polyfill 库来提供支持。在服务器端来说，SSE 是一个不断产生新数据的流，非常适合于用反应式流来表示。在 WebFlux 中创建 SSE 的服务器端是非常简单的。只需要返回的对象的类型是 <code>Flux&lt;ServerSentEvent&gt;</code>，就会被自动按照 SSE 规范要求的格式来发送响应。</p>
<p>代码清单 4 中的 <code>SseController</code> 是一个使用 SSE 的控制器的示例。其中的方法 <code>randomNumbers(</code>表示的是每隔一秒产生一个随机数的 SSE 端点。我们可以使用类 <code>ServerSentEvent.Builder</code> 来创建 <code>ServerSentEvent</code> 对象。这里我们指定了事件名称 random，以及每个事件的标识符和数据。事件的标识符是一个递增的整数，而数据则是产生的随机数。</p>
<h5 id="清单-4-服务器推送事件示例"><a href="#清单-4-服务器推送事件示例" class="headerlink" title="清单 4. 服务器推送事件示例"></a>清单 4. 服务器推送事件示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sse&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SseController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/randomNumbers&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;ServerSentEvent&lt;Integer&gt;&gt; <span class="title function_">randomNumbers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Flux.interval(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">                .map(seq -&gt; Tuples.of(seq, ThreadLocalRandom.current().nextInt()))</span><br><span class="line">                .map(data -&gt; ServerSentEvent.&lt;Integer&gt;builder()</span><br><span class="line">                        .event(<span class="string">&quot;random&quot;</span>)</span><br><span class="line">                        .id(Long.toString(data.getT1()))</span><br><span class="line">                        .data(data.getT2())</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试 SSE 时，我们只需要使用 curl 来访问即可。代码清单 5 给出了调用 curl <a target="_blank" rel="noopener" href="http://localhost:8080/sse/randomNumbers">http://localhost:8080/sse/randomNumbers</a> 的结果。</p>
<p><img src="/images/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81.png" alt="响应式流"></p>
<h5 id="清单-5-SSE-服务器端发送的响应"><a href="#清单-5-SSE-服务器端发送的响应" class="headerlink" title="清单 5. SSE 服务器端发送的响应"></a>清单 5. SSE 服务器端发送的响应</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id:0</span><br><span class="line">event:random</span><br><span class="line">data:751025203</span><br><span class="line"> </span><br><span class="line">id:1</span><br><span class="line">event:random</span><br><span class="line">data:-1591883873</span><br><span class="line"> </span><br><span class="line">id:2</span><br><span class="line">event:random</span><br><span class="line">data:-1899224227</span><br></pre></td></tr></table></figure>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 支持客户端与服务器端的双向通讯。当客户端与服务器端之间的交互方式比较复杂时，可以使用 WebSocket。WebSocket 在主流的浏览器上都得到了支持。WebFlux 也对创建 WebSocket 服务器端提供了支持。在服务器端，我们需要实现接口 org.springframework.web.reactive.socket.WebSocketHandler 来处理 WebSocket 通讯。接口 WebSocketHandler 的方法 handle 的参数是接口 WebSocketSession 的对象，可以用来获取客户端信息、接送消息和发送消息。代码清单 6 中的 EchoHandler 对于每个接收的消息，会发送一个添加了”ECHO -&gt; “前缀的响应消息。WebSocketSession 的 receive 方法的返回值是一个 <code>Flux&lt;WebSocketMessage&gt;</code>对象，表示的是接收到的消息流。而 send 方法的参数是一个 <code>Publisher&lt;WebSocketMessage&gt;</code>对象，表示要发送的消息流。在 handle 方法，使用 map 操作对 receive 方法得到的 <code>Flux&lt;WebSocketMessage&gt;</code>中包含的消息继续处理，然后直接由 send 方法来发送。</p>
<h5 id="清单-6-WebSocket-的-EchoHandler-示例"><a href="#清单-6-WebSocket-的-EchoHandler-示例" class="headerlink" title="清单 6. WebSocket 的 EchoHandler 示例"></a>清单 6. WebSocket 的 EchoHandler 示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoHandler</span> <span class="keyword">implements</span> <span class="title class_">WebSocketHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(<span class="keyword">final</span> WebSocketSession session)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> session.send(</span><br><span class="line">                session.receive()</span><br><span class="line">                        .map(msg -&gt; session.textMessage(<span class="string">&quot;ECHO -&gt; &quot;</span> + msg.getPayloadAsText())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建了 WebSocket 的处理器 EchoHandler 之后，下一步需要把它注册到 WebFlux 中。我们首先需要创建一个类 WebSocketHandlerAdapter 的对象，该对象负责把 WebSocketHandler 关联到 WebFlux 中。代码清单 7 中给出了相应的 Spring 配置。其中的 HandlerMapping 类型的 bean 把 EchoHandler 映射到路径 /echo。</p>
<h5 id="清单-7-注册-EchoHandler"><a href="#清单-7-注册-EchoHandler" class="headerlink" title="清单 7. 注册 EchoHandler"></a>清单 7. 注册 EchoHandler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfiguration</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerMapping <span class="title function_">webSocketMapping</span><span class="params">(<span class="keyword">final</span> EchoHandler echoHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, WebSocketHandler&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;/echo&quot;</span>, echoHandler);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="type">SimpleUrlHandlerMapping</span> <span class="variable">mapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlHandlerMapping</span>();</span><br><span class="line">        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        mapping.setUrlMap(map);</span><br><span class="line">        <span class="keyword">return</span> mapping;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebSocketHandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebSocketHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行应用之后，可以使用工具来测试该 WebSocket 服务。打开工具页面 <a target="_blank" rel="noopener" href="https://www.websocket.org/echo.html">https://www.websocket.org/echo.html</a> ，然后连接到 ws://localhost:8080/echo，可以发送消息并查看服务器端返回的结果。</p>
<h2 id="函数式编程模型"><a href="#函数式编程模型" class="headerlink" title="函数式编程模型"></a>函数式编程模型</h2><p>在上节中介绍了基于 Java 注解的编程模型，WebFlux 还支持基于 lambda 表达式的函数式编程模型。与基于 Java 注解的编程模型相比，函数式编程模型的抽象层次更低，代码编写更灵活，可以满足一些对动态性要求更高的场景。不过在编写时的代码复杂度也较高，学习曲线也较陡。开发人员可以根据实际的需要来选择合适的编程模型。目前 Spring Boot 不支持在一个应用中同时使用两种不同的编程模式。</p>
<p>为了说明函数式编程模型的用法，我们使用 Spring Initializ 来创建一个新的 WebFlux 项目。在函数式编程模型中，每个请求是由一个函数来处理的， 通过接口 <code>org.springframework.web.reactive.function.server.HandlerFunction</code> 来表示。<code>HandlerFunction</code> 是一个函数式接口，其中只有一个方法 <code>Mono&lt;T extends ServerResponse&gt; handle(ServerRequest request)</code>，因此可以用 labmda 表达式来实现该接口。接口 ServerRequest 表示的是一个 HTTP 请求。通过该接口可以获取到请求的相关信息，如请求路径、HTTP 头、查询参数和请求内容等。方法 handle 的返回值是一个 <code>Mono&lt;T extends ServerResponse&gt;</code>对象。接口 ServerResponse 用来表示 HTTP 响应。ServerResponse 中包含了很多静态方法来创建不同 HTTP 状态码的响应对象。本节中通过一个简单的计算器来展示函数式编程模型的用法。代码清单 8 中给出了处理不同请求的类 <code>CalculatorHandler</code>，其中包含的方法 add、subtract、multiply 和 divide 都是接口 HandlerFunction 的实现。这些方法分别对应加、减、乘、除四种运算。每种运算都是从 HTTP 请求中获取到两个作为操作数的整数，再把运算的结果返回。</p>
<h5 id="清单-8-处理请求的类-CalculatorHandler"><a href="#清单-8-处理请求的类-CalculatorHandler" class="headerlink" title="清单 8. 处理请求的类 CalculatorHandler"></a>清单 8. 处理请求的类 CalculatorHandler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorHandler</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">add</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 + v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">subtract</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 - v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt;  <span class="title function_">multiply</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 * v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">divide</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 / v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Mono&lt;ServerResponse&gt; <span class="title function_">calculate</span><span class="params">(<span class="keyword">final</span> ServerRequest request,</span></span><br><span class="line"><span class="params">                                           <span class="keyword">final</span> BiFunction&lt;Integer, Integer, Integer&gt; calculateFunc)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Tuple2&lt;Integer, Integer&gt; operands = extractOperands(request);</span><br><span class="line">        <span class="keyword">return</span> ServerResponse</span><br><span class="line">                .ok()</span><br><span class="line">                .body(Mono.just(calculateFunc.apply(operands.getT1(), operands.getT2())), Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Tuple2&lt;Integer, Integer&gt; <span class="title function_">extractOperands</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Tuples.of(parseOperand(request, <span class="string">&quot;v1&quot;</span>), parseOperand(request, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parseOperand</span><span class="params">(<span class="keyword">final</span> ServerRequest request, <span class="keyword">final</span> String param)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(request.queryParam(param).orElse(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建了处理请求的 HandlerFunction 之后，下一步是为这些 HandlerFunction 提供路由信息，也就是这些 HandlerFunction 被调用的条件。这是通过函数式接口 <code>org.springframework.web.reactive.function.server.RouterFunction</code> 来完成的。接口 <code>RouterFunction</code> 的方法 <code>Mono&lt;HandlerFunction&lt;T extends ServerResponse&gt;&gt; route(ServerRequest request)</code>对每个 <code>ServerRequest</code>，都返回对应的 0 个或 1 个 <code>HandlerFunction</code> 对象，以 <code>Mono&lt;HandlerFunction&gt;</code>来表示。当找到对应的 <code>HandlerFunction</code> 时，该 <code>HandlerFunction</code> 被调用来处理该 ServerRequest，并把得到的 <code>ServerResponse</code> 返回。在使用 <code>WebFlux</code> 的 Spring Boot 应用中，只需要创建 <code>RouterFunction</code> 类型的 bean，就会被自动注册来处理请求并调用相应的 <code>HandlerFunction</code>。</p>
<p>代码清单 9 给了示例相关的配置类 Config。方法 <code>RouterFunctions.route</code> 用来根据 <code>Predicate</code> 是否匹配来确定 <code>HandlerFunction</code> 是否被应用。<code>RequestPredicates</code> 中包含了很多静态方法来创建常用的基于不同匹配规则的 <code>Predicate</code>。如 <code>RequestPredicates.path</code> 用来根据 HTTP 请求的路径来进行匹配。此处我们检查请求的路径是/calculator。在清单 9 中，我们首先使用 <code>ServerRequest</code> 的 queryParam 方法来获取到查询参数 operator 的值，然后通过反射 API 在类 <code>CalculatorHandler</code> 中找到与查询参数 operator 的值名称相同的方法来确定要调用的 <code>HandlerFunction</code> 的实现，最后调用查找到的方法来处理该请求。如果找不到查询参数 <code>operator</code> 或是 <code>operator</code> 的值不在识别的列表中，服务器端返回 400 错误；如果反射 API 的方法调用中出现错误，服务器端返回 500 错误。</p>
<h5 id="清单-9-注册-RouterFunction"><a href="#清单-9-注册-RouterFunction" class="headerlink" title="清单 9. 注册 RouterFunction"></a>清单 9. 注册 RouterFunction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt;routerFunction(<span class="keyword">final</span> CalculatorHandler calculatorHandler) &#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(RequestPredicates.path(<span class="string">&quot;/calculator&quot;</span>), request -&gt;</span><br><span class="line">                request.queryParam(<span class="string">&quot;operator&quot;</span>).map(operator -&gt;</span><br><span class="line">                        Mono.justOrEmpty(ReflectionUtils.findMethod(CalculatorHandler.class, operator, ServerRequest.class))</span><br><span class="line">                                .flatMap(method -&gt; (Mono&lt;ServerResponse&gt;) ReflectionUtils.invokeMethod(method, calculatorHandler, request))</span><br><span class="line">                                .switchIfEmpty(ServerResponse.badRequest().build())</span><br><span class="line">                                .onErrorResume(ex -&gt; ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR).build()))</span><br><span class="line">                        .orElse(ServerResponse.badRequest().build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>除了服务器端实现之外，WebFlux 也提供了反应式客户端，可以访问 HTTP、SSE 和 WebSocket 服务器端。</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>对于 HTTP 和 SSE，可以使用 WebFlux 模块中的类 <code>org.springframework.web.reactive.function.client.WebClient</code>。代码清单 10 中的 RESTClient 用来访问前面小节中创建的 REST API。首先使用 <code>WebClient.create</code> 方法来创建一个新的 <code>WebClient</code> 对象，然后使用方法 post 来创建一个 POST 请求，并使用方法 body 来设置 POST 请求的内容。方法 exchange 的作用是发送请求并得到以 <code>Mono&lt;ServerResponse&gt;</code>表示的 HTTP 响应。最后对得到的响应进行处理并输出结果。<code>ServerResponse</code> 的 <code>bodyToMono</code> 方法把响应内容转换成类 <code>User</code> 的对象，最终得到的结果是 <code>Mono&lt;User&gt;</code>对象。调用 <code>createdUser.block</code> 方法的作用是等待请求完成并得到所产生的类 <code>User</code> 的对象。</p>
<h5 id="清单-10-使用-WebClient-访问-REST-API"><a href="#清单-10-使用-WebClient-访问-REST-API" class="headerlink" title="清单 10. 使用 WebClient 访问 REST API"></a>清单 10. 使用 WebClient 访问 REST API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RESTClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;test@example.org&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create(<span class="string">&quot;http://localhost:8080/user&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> Monol&lt;User&gt; createdUser = client.post()</span><br><span class="line">                .uri(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(Mono.just(user), User.class)</span><br><span class="line">                .exchange()</span><br><span class="line">                .flatMap(response -&gt; response.bodyToMono(User.class));</span><br><span class="line">        System.out.println(createdUser.block());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><p>WebClient 还可以用同样的方式来访问 SSE 服务，如代码清单 11 所示。这里我们访问的是在之前的小节中创建的生成随机数的 SSE 服务。使用 WebClient 访问 SSE 在发送请求部分与访问 REST API 是相同的，所不同的地方在于对 HTTP 响应的处理。由于 SSE 服务的响应是一个消息流，我们需要使用 <code>flatMapMany</code> 把 <code>Mono&lt;ServerResponse&gt;</code>转换成一个 <code>Flux&lt;ServerSentEvent&gt;</code>对象，这是通过方法 <code>BodyExtractors.toFlux</code> 来完成的，其中的参数 <code>new ParameterizedTypeReference&lt;ServerSentEvent&lt;String&gt;&gt;() &#123;&#125;</code>表明了响应消息流中的内容是 <code>ServerSentEvent</code> 对象。由于 SSE 服务器会不断地发送消息，这里我们只是通过 buffer 方法来获取前 10 条消息并输出。</p>
<h5 id="清单-11-使用-WebClient-访问-SSE-服务"><a href="#清单-11-使用-WebClient-访问-SSE-服务" class="headerlink" title="清单 11. 使用 WebClient 访问 SSE 服务"></a>清单 11. 使用 WebClient 访问 SSE 服务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SSEClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create();</span><br><span class="line">        client.get()</span><br><span class="line">                .uri(<span class="string">&quot;http://localhost:8080/sse/randomNumbers&quot;</span>)</span><br><span class="line">                .accept(MediaType.TEXT_EVENT_STREAM)</span><br><span class="line">                .exchange()</span><br><span class="line">                .flatMapMany(response -&gt; response.body(BodyExtractors.toFlux(<span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;ServerSentEvent&lt;String&gt;&gt;() &#123;</span><br><span class="line">                &#125;)))</span><br><span class="line">                .filter(sse -&gt; Objects.nonNull(sse.data()))</span><br><span class="line">                .map(ServerSentEvent::data)</span><br><span class="line">                .buffer(<span class="number">10</span>)</span><br><span class="line">                .doOnNext(System.out::println)</span><br><span class="line">                .blockFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>访问 WebSocket 不能使用 WebClient，而应该使用专门的 WebSocketClient 客户端。Spring Boot 的 WebFlux 模板中默认使用的是 Reactor Netty 库。Reactor Netty 库提供了 WebSocketClient 的实现。在代码清单 12 中，我们访问的是上面小节中创建的 WebSocket 服务。WebSocketClient 的 execute 方法与 WebSocket 服务器建立连接，并执行给定的 WebSocketHandler 对象。该 WebSocketHandler 对象与代码清单 6 中的作用是一样的，只不过它是工作于客户端，而不是服务器端。在 WebSocketHandler 的实现中，首先通过 WebSocketSession 的 send 方法来发送字符串 Hello 到服务器端，然后通过 receive 方法来等待服务器端的响应并输出。方法 take(1)的作用是表明客户端只获取服务器端发送的第一条消息。</p>
<h5 id="清单-12-使用-WebSocketClient-访问-WebSocket"><a href="#清单-12-使用-WebSocketClient-访问-WebSocket" class="headerlink" title="清单 12. 使用 WebSocketClient 访问 WebSocket"></a>清单 12. 使用 WebSocketClient 访问 WebSocket</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WSClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">WebSocketClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReactorNettyWebSocketClient</span>();</span><br><span class="line">        client.execute(URI.create(<span class="string">&quot;ws://localhost:8080/echo&quot;</span>), session -&gt;</span><br><span class="line">                session.send(Flux.just(session.textMessage(<span class="string">&quot;Hello&quot;</span>)))</span><br><span class="line">                        .thenMany(session.receive().take(<span class="number">1</span>).map(WebSocketMessage::getPayloadAsText))</span><br><span class="line">                        .doOnNext(System.out::println)</span><br><span class="line">                        .then())</span><br><span class="line">                .block(Duration.ofMillis(<span class="number">5000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在 spring-test 模块中也添加了对 WebFlux 的支持。通过类 <code>org.springframework.test.web.reactive.server.WebTestClient</code> 可以测试 WebFlux 服务器。进行测试时既可以通过 mock 的方式来进行，也可以对实际运行的服务器进行集成测试。代码清单 13 通过一个集成测试来测试 UserController 中的创建用户的功能。方法 <code>WebTestClient.bindToServer</code> 绑定到一个运行的服务器并设置了基础 URL。发送 HTTP 请求的方式与代码清单 10 相同，不同的是 <code>exchange</code> 方法的返回值是 ResponseSpec 对象，其中包含了 <code>expectStatus</code> 和 <code>expectBody</code> 等方法来验证 HTTP 响应的状态码和内容。方法 <code>jsonPath</code> 可以根据 JSON 对象中的路径来进行验证。</p>
<h5 id="清单-13-测试-UserController"><a href="#清单-13-测试-UserController" class="headerlink" title="清单 13. 测试 UserController"></a>清单 13. 测试 UserController</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WebTestClient</span> <span class="variable">client</span> <span class="operator">=</span> WebTestClient.bindToServer().baseUrl(<span class="string">&quot;http://localhost:8080&quot;</span>).build();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreateUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;test@example.org&quot;</span>);</span><br><span class="line">        client.post().uri(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(Mono.just(user), User.class)</span><br><span class="line">                .exchange()</span><br><span class="line">                .expectStatus().isOk()</span><br><span class="line">                .expectBody().jsonPath(<span class="string">&quot;name&quot;</span>).isEqualTo(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>反应式编程范式为开发高性能 Web 应用带来了新的机会和挑战。Spring 5 中的 WebFlux 模块可以作为开发反应式 Web 应用的基础。由于 Spring 框架的流行，WebFlux 会成为开发 Web 应用的重要趋势之一。本文对 Spring 5 中的 WebFlux 模块进行了详细的介绍，包括如何用 WebFlux 开发 HTTP、SSE 和 WebSocket 服务器端应用，以及作为客户端来访问 HTTP、SSE 和 WebSocket 服务。对于 WebFlux 的基于 Java 注解和函数式编程等两种模型都进行了介绍。最后介绍了如何测试 WebFlux 应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hejianjun.github.io/2018/06/29/spring-webflux/" data-id="clma8n993003e50w3fpynbmf1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webflux/" rel="tag">webflux</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/05/SQL/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SQL
        
      </div>
    </a>
  
  
    <a href="/2018/06/14/spring-cache/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Spring注解缓存</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/technology/AOP/">AOP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/technology/AOP/AspectJ/">AspectJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/AOP/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/Apache-Commons/">Apache Commons</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/CAS/">CAS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/CI/">CI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/ChatGPT/">ChatGPT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/DBMS/">DBMS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/JD-GUI/">JD-GUI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/JPDA/">JPDA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/Modbus/">Modbus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/NAT/">NAT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/OCJP/">OCJP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/cache/">cache</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/technology/cache/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/dubbo/">dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/kettel/">kettel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/sql/">sql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/thingsboard/">thingsboard</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/webflux/">webflux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86/">业务知识</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86/%E6%B3%95%E9%99%A2/">法院</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache-Commons/" rel="tag">Apache Commons</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CI/" rel="tag">CI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/" rel="tag">ChatGPT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DBMS/" rel="tag">DBMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JD-GUI/" rel="tag">JD-GUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPDA/" rel="tag">JPDA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modbus/" rel="tag">Modbus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OCJP/" rel="tag">OCJP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSO/" rel="tag">SSO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aspectJ/" rel="tag">aspectJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cache/" rel="tag">cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitflow/" rel="tag">gitflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kettle/" rel="tag">kettle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thingsboard/" rel="tag">thingsboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webflux/" rel="tag">webflux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" rel="tag">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%95%E9%99%A2%E4%B8%9A%E5%8A%A1/" rel="tag">法院业务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 16.67px;">AOP</a> <a href="/tags/Apache-Commons/" style="font-size: 10px;">Apache Commons</a> <a href="/tags/CI/" style="font-size: 10px;">CI</a> <a href="/tags/ChatGPT/" style="font-size: 10px;">ChatGPT</a> <a href="/tags/DBMS/" style="font-size: 10px;">DBMS</a> <a href="/tags/JD-GUI/" style="font-size: 10px;">JD-GUI</a> <a href="/tags/JPDA/" style="font-size: 13.33px;">JPDA</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Modbus/" style="font-size: 10px;">Modbus</a> <a href="/tags/OCJP/" style="font-size: 16.67px;">OCJP</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SSO/" style="font-size: 10px;">SSO</a> <a href="/tags/aspectJ/" style="font-size: 10px;">aspectJ</a> <a href="/tags/cache/" style="font-size: 16.67px;">cache</a> <a href="/tags/distributed/" style="font-size: 10px;">distributed</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gitflow/" style="font-size: 10px;">gitflow</a> <a href="/tags/kettle/" style="font-size: 16.67px;">kettle</a> <a href="/tags/spring/" style="font-size: 13.33px;">spring</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/thingsboard/" style="font-size: 10px;">thingsboard</a> <a href="/tags/webflux/" style="font-size: 10px;">webflux</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 10px;">内网穿透</a> <a href="/tags/%E6%B3%95%E9%99%A2%E4%B8%9A%E5%8A%A1/" style="font-size: 20px;">法院业务</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/08/JD-GUI/">JD-GUI</a>
          </li>
        
          <li>
            <a href="/2023/09/07/thingsboard/">thingsboard</a>
          </li>
        
          <li>
            <a href="/2023/09/06/Modbus-TCP/">Modbus TCP/IP</a>
          </li>
        
          <li>
            <a href="/2023/09/05/ChatGPT/">ChatGPT</a>
          </li>
        
          <li>
            <a href="/2020/08/06/git/">git</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Hejianjun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>